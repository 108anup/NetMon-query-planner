import hashlib
import math
import os
import re
import subprocess

import numpy as np

from common import PROJECT_ROOT, log
from config import common_config
from input import get_complete_graph


class FastModularity():

    """
    Adapted from:
    https://github.com/netcontract/ncflow/blob/master/lib/partitioning/fm_partitioning.py
    """

    run_folder = os.path.join(PROJECT_ROOT, 'ext', 'modularity', 'rundir')
    stdout_folder = os.path.join(run_folder, 'runs')
    if not os.path.exists(run_folder):
        os.makedirs(run_folder)
        os.makedirs(stdout_folder)
    exe_folder = os.path.join(
        PROJECT_ROOT, 'ext', 'modularity', 'FastCommunity_w_GPL_v1.0.1')
    fm_exe = os.path.join(exe_folder, 'FastCommunity_wMH')
    if not os.path.exists(fm_exe):
        curr_dir = os.getcwd()
        os.chdir(exe_folder)
        subprocess.call(['make'])
        os.chdir(curr_dir)

    def get_overlay(self, inp, topology):
        g = get_complete_graph(inp)
        topo = topology.get_pickle_name()

        # write weighted pairs to file
        wpfile = os.path.join(self.run_folder, topo + '.wpairs')
        with open(wpfile, "w") as outF:
            for (u, v, wt) in g.edges:
                outF.write("%d\t%d\t%d\n" % (u, v, wt+1))

        if not hasattr(self, '_num_partitions'):
            devices_per_cluster = common_config.MAX_CLUSTERS_PER_CLUSTER
            if(common_config.solver == 'Netmon'):
                devices_per_cluster = common_config.MAX_DEVICES_PER_CLUSTER
            self._num_partitions = math.ceil(
                len(g.nodes) / devices_per_cluster)

            # # TODO: maybe try this approach as well?
            # # Run without num partitions argument to determine optimal number
            # # of partitions based on modularity
            # cmd = self.fm_exe + ' -f ' + wpfile + \
            #     ' | grep ^Q | sort -g -r -k3 | head -n 1 | sed -e "s/\[/ /g" | sed -e "s/\]/ /g" | awk \'{print $2}\''
            # print('cmd=[{}]'.format(cmd))

            # self._num_partitions = len(g.nodes) - int(os.popen(cmd).read())
            # print('opt #partitions= ', self._num_partitions)

        # Run with num partitions argument, save to temporary output file
        fm_param = len(g.nodes) - self._num_partitions
        # TODO: check how does -c X relate with modularity
        # and number of clusters
        cmd = self.fm_exe + ' -f ' + wpfile + ' -c ' + str(fm_param)
        print('cmd=[{}]'.format(cmd))

        temp_fname = hashlib.md5(
            np.int64(np.random.randint(2**31 - 1))).hexdigest()
        temp_fpath = os.path.join(self.stdout_folder, temp_fname)
        with open(temp_fpath, 'w') as w:
            subprocess.call(cmd, shell=True, stdout=w)

        # Extract time
        output = os.popen('grep "Total Time:" {}'.format(temp_fpath)).read()
        match = re.match('Total Time: (\d+(\.\d+)?) seconds', output)
        self.runtime = float(match.group(1))

        # Extract modularity score
        output = os.popen('grep "^Q\['+ str(fm_param) + '\]" '
                          + temp_fpath
                          + ' | sed -e "s/\[/ /g"'
                          + ' | sed -e "s/\]/ /g" | awk \'{print $4}\'').read()
        self.modularity = float(output)
        print('Modularity:', self.modularity)

        # Remove temporary output file
        os.remove(temp_fpath)

        # Read partition vector from output file generated by FM
        overlay = []
        this_group = []
        partition_vector = np.ones(len(g.nodes), dtype=np.int32) * -1
        currgroup = -1
        group_file_name = os.path.join(self.run_folder, topo + '-fc_a.groups')
        assigned_group = 0
        with open(group_file_name, "r") as groups:
            for line in groups:
                if line.startswith("GROUP"):
                    currgroup += 1
                    if(len(this_group) > 0):
                        overlay.append(this_group)
                    this_group = []
                else:
                    assigned_group += 1
                    this_group.append(int(line))
                    partition_vector[int(line)] = currgroup
        if(len(this_group) > 0):
            overlay.append(this_group)
        this_group = []
        for dnum, cnum in enumerate(partition_vector):
            if(cnum == -1):
                this_group.append(dnum)
                assigned_group += 1
        if(len(this_group) > 0):
            overlay.append(this_group)

        # assert np.sum(partition_vector == -1) == 0
        assert(assigned_group == len(inp.devices))
        log.info(partition_vector)
        return overlay
